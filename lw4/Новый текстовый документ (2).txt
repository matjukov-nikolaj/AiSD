PROGRAM AlgoritmPrima(INPUT, OUTPUT);
{   20. Реализовать  алгоритм   Прима   нахождения   остовного 
дерева и проиллюстрировать по шагам этапы его выполнения (10).

                 Матюков Николай Юрьевич ПС-21
}
CONST
  NO_FILE = 'Не указан исходный файл';
  ERROR_OPEN_FILE = 'Ошибка открытия файла ';
  SPACE = ' ';
  FirstNodeInfo = 1;
  SecondNodeInfo = 2;
  NodeCost = 3;
  

TYPE
  InfoSize = 1..3;
  NodeInfo = ARRAY [InfoSize] OF INTEGER;
  NodePtr = ^Node;
  Node = RECORD
           Next, Prev: NodePtr;
           Key: NodeInfo;
         END;
  TreeInfo = RECORD
               First, Second, Cost: INTEGER;
               Tag: BOOLEAN;
             END;
VAR
  FirstPtr, NewPtr: NodePtr;
  FIn, FOut: TEXT;
  NodeCount: INTEGER;
  SetOfUnChosenNode: SET OF BYTE;
  SetOfChosenNode: SET OF BYTE;

PROCEDURE WriteStringInOut(Alert: STRING);
BEGIN {WriteStringInOut}
  WRITELN(Alert);
  READLN;
  Halt;
END; {WriteStringInOut}

PROCEDURE ErrorOpenFile(VAR FileName: STRING);
BEGIN
  IF IoResult <> 0 
  THEN
    WriteStringInOut(ERROR_OPEN_FILE + FileName);
END;

PROCEDURE CheckEnteredFile(VAR FIn, FOut:TEXT);
VAR 
  FileName: STRING;
BEGIN {CheckEnteredFile}
  IF ParamCount < 2
  THEN
    WriteStringInOut(NO_FILE)
  ELSE
    BEGIN
      ASSIGN(FOut, ParamStr(2));
      ASSIGN(FIn, ParamStr(1));
    END;
  FileName := ParamStr(1);
  {$I-}
  RESET(FIn);           
  {$I+}  
  ErrorOpenFile(FileName);
  FileName := ParamStr(2);
  {$I-}
  REWRITE(FOut);
  {$I+}
  ErrorOpenFile(FileName);
END; {CheckEnteredFile}

PROCEDURE PrintGraphNodes(VAR FirstPtr: NodePtr);
VAR
  Ptr: NodePtr;
  I: INTEGER;
BEGIN
  Ptr := FirstPtr;
  WHILE Ptr <> NIL
  DO
    BEGIN
	  FOR I := FirstNodeInfo TO NodeCost
	  DO
	    BEGIN
	      IF I = SecondNodeInfo
	      THEN
	        WRITE(' -> ');
	      IF I = NodeCost
	      THEN
	        WRITE(' Cost = ');
	      WRITE(Ptr^.Key[I]);
	    END;
	  Ptr := Ptr^.Next;
	  WRITELN
    END
END;

PROCEDURE InsertNewNode(VAR NewPtr: NodePtr; VAR FirstPtr: NodePtr; VAR NodeCount: INTEGER);
VAR
  CurrNode: NodePtr;
  Found: BOOLEAN;
	
BEGIN
  CurrNode := FirstPtr;
  Found := FALSE;
  WHILE (CurrNode^.Next <> NIL) AND NOT Found
  DO
    IF NewPtr^.Key[FirstNodeInfo] > CurrNode^.Key[FirstNodeInfo]
    THEN
	  CurrNode := CurrNode^.Next
    ELSE
	  Found := TRUE;
  IF NewPtr^.Key[FirstNodeInfo] < CurrNode^.Key[FirstNodeInfo]
  THEN
    BEGIN
      IF (CurrNode^.Prev <> NIL) AND (CurrNode^.Prev^.Next <> NIL)
      THEN
        BEGIN
          CurrNode^.Prev^.Next := NewPtr;
          NewPtr^.Prev := CurrNode^.Prev;
        END;
      NewPtr^.Next := CurrNode;
      CurrNode^.Prev := NewPtr;
    END
  ELSE
    BEGIN
      IF (CurrNode^.Next <> NIL) AND (CurrNode^.Next^.Prev <> NIL)
      THEN
        BEGIN    
          CurrNode^.Next^.Prev := NewPtr;
          NewPtr^.Next := CurrNode^.Next;
        END;
      NewPtr^.Prev := CurrNode;
      CurrNode^.Next := NewPtr;
    END;
  IF NewPtr^.Prev = NIL
  THEN
    FirstPtr := NewPtr;
  IF (CurrNode^.Prev <> NIL) AND (NewPtr^.Key[FirstNodeInfo] <> CurrNode^.Key[FirstNodeInfo])
  THEN
    BEGIN
      INC(NodeCount);
    END;
END;

PROCEDURE CreateNewNodeConnection(Node: NodeInfo);
BEGIN
  NEW(NewPtr);
  NewPtr^.Key := Node; 
  NewPtr^.Prev := NIL;
  NewPtr^.Next := NIL;
END;

PROCEDURE ReadGraph(VAR FIn: TEXT; VAR NodeCount: INTEGER);
VAR
  CurrNum, I: INTEGER;
  IsFirst: BOOLEAN;
  NodesInfo: NodeInfo;
BEGIN
  FirstPtr := NIL;
  IsFirst := TRUE;
  WHILE NOT EOF(FIn)
  DO
    BEGIN
      I := 1;
      WHILE NOT EOLN(FIn)
      DO
        BEGIN
          READ(FIn, CurrNum);
          NodesInfo[I] := CurrNum;
          INC(I);
        END;
      CreateNewNodeConnection(NodesInfo);
      IF IsFirst
      THEN
        BEGIN
          FirstPtr := NewPtr;
          IsFirst := FALSE;
        END
      ELSE
        InsertNewNode(NewPtr, FirstPtr, NodeCount);
      READLN(FIn);
    END;
  PrintGraphNodes(FirstPtr);
END;

PROCEDURE GetNodeWithMinCost(First: NodePtr; VAR Node: NodePtr; MinKey: NodeInfo);
VAR
  Ptr: NodePtr;
BEGIN
  Ptr := First;
  WHILE Ptr <> NIL
  DO
    BEGIN
      IF ((Ptr^.Key[FirstNodeInfo] = MinKey[SecondNodeInfo]))
      AND NOT (Ptr^.Key[SecondNodeInfo] IN SetOfChosenNode)
      THEN
        BEGIN
          Node := Ptr;
          BREAK;
        END;
      Ptr := Ptr^.Next;
    END;
END;

PROCEDURE GetOstovnyTree(FirstPtr: NodePtr; NodeCount: INTEGER);
VAR
  CurrNode, I: INTEGER;
  Node, NodeMinCost: NodePtr;
  TableOfNode: ARRAY OF TreeInfo;
BEGIN
  //WRITELN('(. )( .)');
  SetLength(TableOfNode, NodeCount + 1);
  FOR I := 1 TO Length(TableOfNode)
  DO
    BEGIN
      TableOfNode[I].First := -1;
      TableOfNode[I].Second := -1;
      TableOfNode[I].Cost := -1;
      TableOfNode[I].Tag := FALSE;
    END;
  SetOfChosenNode := [];
  SetOfUnChosenNode := [];
  Node := FirstPtr;
  NodeMinCost := FirstPtr;
  CurrNode := Node^.Key[FirstNodeInfo];
  INCLUDE(SetOfChosenNode, CurrNode);
  WHILE Node <> NIL
  DO
    BEGIN
      IF Node^.Key[FirstNodeInfo] = CurrNode
      THEN
        Node := Node^.Next
      ELSE
        BEGIN
          CurrNode := Node^.Key[FirstNodeInfo];
          INCLUDE(SetOfUnChosenNode, CurrNode);
        END;
    END; 
  Node := FirstPtr;
  CurrNode := Node^.Key[FirstNodeInfo];
  I := Node^.Key[SecondNodeInfo];
  INCLUDE(SetOfChosenNode, CurrNode); 
  SetOfUnChosenNode := SetOfUnChosenNode - [CurrNode];    
  WHILE SetOfUnChosenNode <> []
  DO
    BEGIN
      WHILE (Node^.Key[FirstNodeInfo] = CurrNode)
      DO
        BEGIN
          IF (TableOfNode[I].First <> -1) AND (TableOfNode[I].Tag <> FALSE)
          THEN
            BEGIN
              TableOfNode[I].First := Node^.Key[FirstNodeInfo];
              TableOfNode[I].Second := Node^.Key[SecondNodeInfo];
              TableOfNode[I].Cost := Node^.Key[NodeCost];
            END;
          Node := Node^.Next;
          I := Node^.Key[SecondNodeInfo];
        END;
    END;
END;

BEGIN
  NodeCount := 1;
  CheckEnteredFile(FIn, FOut);
  ReadGraph(FIn, NodeCount);
  //GetOstovnyTree(FirstPtr, NodeCount);
END.
