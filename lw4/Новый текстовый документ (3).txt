PROGRAM AlgoritmPrima(INPUT, OUTPUT);
{   20. Реализовать  алгоритм   Прима   нахождения   остовного 
дерева и проиллюстрировать по шагам этапы его выполнения (10).

                 Матюков Николай Юрьевич ПС-21
}
CONST
  NO_FILE = 'Не указан исходный файл';
  ERROR_OPEN_FILE = 'Ошибка открытия файла ';
  SPACE = ' ';
  FirstNodeInfo = 1;
  SecondNodeInfo = 2;
  NodeCost = 3;
  

TYPE
  InfoSize = 1..3;
  NodeInfo = ARRAY [InfoSize] OF INTEGER;
  NodePtr = ^Node;
  Node = RECORD
           Next, Prev: NodePtr;
           Key: NodeInfo;
         END;
  TableInfo = RECORD
               First, Second, Cost: INTEGER;
               Tag: BOOLEAN;
             END;
VAR
  FirstPtr, NewPtr: NodePtr;
  FIn, FOut: TEXT;
  NodeCount: INTEGER;
  SetChosenNodes: SET OF BYTE;

PROCEDURE WriteStringInOut(Alert: STRING);
BEGIN {WriteStringInOut}
  WRITELN(Alert);
  READLN;
  Halt;
END; {WriteStringInOut}

PROCEDURE ErrorOpenFile(VAR FileName: STRING);
BEGIN
  IF IoResult <> 0 
  THEN
    WriteStringInOut(ERROR_OPEN_FILE + FileName);
END;

PROCEDURE CheckEnteredFile(VAR FIn, FOut:TEXT);
VAR 
  FileName: STRING;
BEGIN {CheckEnteredFile}
  IF ParamCount < 2
  THEN
    WriteStringInOut(NO_FILE)
  ELSE
    BEGIN
      ASSIGN(FOut, ParamStr(2));
      ASSIGN(FIn, ParamStr(1));
    END;
  FileName := ParamStr(1);
  {$I-}
  RESET(FIn);           
  {$I+}  
  ErrorOpenFile(FileName);
  FileName := ParamStr(2);
  {$I-}
  REWRITE(FOut);
  {$I+}
  ErrorOpenFile(FileName);
END; {CheckEnteredFile}

PROCEDURE PrintGraphNodes(VAR FirstPtr: NodePtr);
VAR
  Ptr: NodePtr;
  I: INTEGER;
BEGIN
  Ptr := FirstPtr;
  WHILE Ptr <> NIL
  DO
    BEGIN
	  FOR I := FirstNodeInfo TO NodeCost
	  DO
	    BEGIN
	      IF I = SecondNodeInfo
	      THEN
	        WRITE(' -> ');
	      IF I = NodeCost
	      THEN
	        WRITE(' Cost = ');
	      WRITE(Ptr^.Key[I]);
	    END;
	  Ptr := Ptr^.Next;
	  WRITELN
    END
END;

PROCEDURE InsertNewNode(VAR NewPtr: NodePtr; VAR FirstPtr: NodePtr);
VAR
  CurrNode: NodePtr;
  Found: BOOLEAN;
	
BEGIN
  CurrNode := FirstPtr;
  Found := FALSE;
  WHILE (CurrNode^.Next <> NIL) AND NOT Found
  DO
    IF NewPtr^.Key[FirstNodeInfo] > CurrNode^.Key[FirstNodeInfo]
    THEN
	  CurrNode := CurrNode^.Next
    ELSE
	  Found := TRUE;
  IF NewPtr^.Key[FirstNodeInfo] < CurrNode^.Key[FirstNodeInfo]
  THEN
    BEGIN
      IF (CurrNode^.Prev <> NIL) AND (CurrNode^.Prev^.Next <> NIL)
      THEN
        BEGIN
          CurrNode^.Prev^.Next := NewPtr;
          NewPtr^.Prev := CurrNode^.Prev;
        END;
      NewPtr^.Next := CurrNode;
      CurrNode^.Prev := NewPtr;
    END
  ELSE
    BEGIN
      IF (CurrNode^.Next <> NIL) AND (CurrNode^.Next^.Prev <> NIL)
      THEN
        BEGIN    
          CurrNode^.Next^.Prev := NewPtr;
          NewPtr^.Next := CurrNode^.Next;
        END;
      NewPtr^.Prev := CurrNode;
      CurrNode^.Next := NewPtr;
    END;
  IF NewPtr^.Prev = NIL
  THEN
    FirstPtr := NewPtr;
END;

PROCEDURE CreateNewNodeConnection(Node: NodeInfo);
BEGIN
  NEW(NewPtr);
  NewPtr^.Key := Node; 
  NewPtr^.Prev := NIL;
  NewPtr^.Next := NIL;
END;

PROCEDURE ReadGraph(VAR FIn: TEXT);
VAR
  CurrNum, I: INTEGER;
  IsFirst: BOOLEAN;
  NodesInfo: NodeInfo;
BEGIN
  READLN(FIn, NodeCount);
  FirstPtr := NIL;
  IsFirst := TRUE;
  WHILE NOT EOF(FIn)
  DO
    BEGIN
      I := 1;
      WHILE NOT EOLN(FIn)
      DO
        BEGIN
          READ(FIn, CurrNum);
          NodesInfo[I] := CurrNum;
          INC(I);
        END;
      CreateNewNodeConnection(NodesInfo);
      IF IsFirst
      THEN
        BEGIN
          FirstPtr := NewPtr;
          IsFirst := FALSE;
        END
      ELSE
        InsertNewNode(NewPtr, FirstPtr);
      READLN(FIn);
    END;
  PrintGraphNodes(FirstPtr);
END;

PROCEDURE PrintTable(Table: ARRAY OF TableInfo);
VAR
  I: INTEGER;
BEGIN
  FOR I := 2 TO (Length(Table) - 1)
  DO
    BEGIN
      IF I = 2
      THEN
        WRITE(' | ');
      IF NOT Table[I].Tag 
      THEN
        WRITE(Table[I].First, '->', 
        Table[I].Second, ' (', Table[I].Cost, ') | ')
      ELSE
        WRITE(Table[I].First, '->', 
        Table[I].Second, ' (', Table[I].Cost, ') * | ');
    END;
  WRITELN;
END;

PROCEDURE CheckAllSelected(Table: ARRAY OF TableInfo;VAR AllSelected: BOOLEAN);
VAR
  I, TagCounter: INTEGER;
BEGIN
  TagCounter := 0;
  FOR I := 2 TO (Length(Table) - 1)
  DO
    IF Table[I].Tag
    THEN
      INC(TagCounter);
  IF TagCounter = NodeCount - 1
  THEN
    AllSelected := TRUE;
END;

PROCEDURE PrintSet;
VAR
  I: INTEGER;
BEGIN
  WRITE('[');
  FOR I := 0 TO 255
  DO
    BEGIN
      IF I IN SetChosenNodes
      THEN
        WRITE(I, ' ');
    END;
  WRITELN(']');
END;

PROCEDURE InitTable(VAR Table: ARRAY OF TableInfo);
VAR
  I: INTEGER;
BEGIN
  FOR I := 2 TO (Length(Table) - 1)
  DO
    BEGIN
      Table[I].First := MAXINT;
      Table[I].Second := MAXINT;
      Table[I].Cost := MAXINT;
      Table[I].Tag := FALSE;
    END;
END;

PROCEDURE InsertInTable(VAR Node: NodePtr;VAR Table: ARRAY OF TableInfo; VAR CurrNode, I: INTEGER);
BEGIN
  WHILE (Node^.Key[FirstNodeInfo] = CurrNode)
  DO
    BEGIN
      IF (Table[I].Tag = FALSE)
        AND (Node^.Key[NodeCost] < Table[I].Cost)
        AND NOT (Node^.Key[SecondNodeInfo] IN SetChosenNodes)
      THEN
        BEGIN
          Table[I].First := Node^.Key[FirstNodeInfo];
          Table[I].Second := Node^.Key[SecondNodeInfo];
          Table[I].Cost := Node^.Key[NodeCost];
          WRITELN('Insert Node: ',
          Table[I].First, ' ',
          Table[I].Second, ' ',
          Table[I].Cost, ' On Position: ', I
          );
        END;
      IF Node^.Next <> NIL
      THEN
        Node := Node^.Next
      ELSE
        BREAK;
      I := Node^.Key[SecondNodeInfo];
    END;
END;

PROCEDURE GetNodeWithMinCost(VAR MinCost, NodeMinCost: INTEGER; VAR Table: ARRAY OF TableInfo);
VAR
  I: INTEGER;
BEGIN
  I := 2;
  IF Table[I].Tag
  THEN
    BEGIN
      WHILE Table[I].Tag
      DO
        INC(I);
      MinCost := Table[I].Cost;
      NodeMinCost := Table[I].Second;
      Table[I].Tag := TRUE;
    END
  ELSE
    BEGIN
      MinCost := Table[I].Cost;
      NodeMinCost := Table[I].Second;
    END;
  FOR I := 2 TO Length(Table) - 1 
  DO
    BEGIN
      IF (Table[I].Cost < MinCost) AND (Table[I].Tag = FALSE)
      THEN
        BEGIN
          NodeMinCost := Table[I].Second;
          MinCost := Table[I].Cost;
          Table[I].Tag := TRUE;
        END
    END;
  IF MinCost = Table[2].Cost
  THEN
    BEGIN
      NodeMinCost := Table[2].Second;
      Table[2].Tag := TRUE;
    END;
  //WRITELN('MinCost = ', MinCost);
  //WRITELN('NodeMinCost = ', NodeMinCost);
END;

PROCEDURE GetOstovnyTree(FirstPtr: NodePtr);
VAR
  CurrNode, I, NodeMinCost, MinCost: INTEGER;
  Node: NodePtr;
  AllSelected: BOOLEAN;
  TableOfNodes: ARRAY OF TableInfo;
BEGIN
  //WRITELN('(. )( .)');
  SetLength(TableOfNodes, NodeCount + 1);
  InitTable(TableOfNodes);
  AllSelected := FALSE;
  Node := FirstPtr;
  CurrNode := Node^.Key[FirstNodeInfo];
  I := Node^.Key[SecondNodeInfo]; 
  INCLUDE(SetChosenNodes, Node^.Key[FirstNodeInfo]);
  WHILE AllSelected <> TRUE
  DO
    BEGIN
      InsertInTable(Node, TableOfNodes, CurrNode, I);
      GetNodeWithMinCost(MinCost, NodeMinCost, TableOfNodes);
      Node := FirstPtr;
      WHILE (Node^.Key[FirstNodeInfo] <> NodeMinCost) AND (Node^.Next <> NIL)
      DO
        Node := Node^.Next;
      INCLUDE(SetChosenNodes, Node^.Key[FirstNodeInfo]);
      CheckAllSelected(TableOfNodes, AllSelected);
      CurrNode := Node^.Key[FirstNodeInfo];
      IF NOT (Node^.Key[SecondNodeInfo] IN SetChosenNodes)
      THEN
        BEGIN
          I := Node^.Key[SecondNodeInfo];
        END;
      NodeMinCost := MAXINT;
      PrintTable(TableOfNodes);
    END;
END;

BEGIN
  NodeCount := 1;
  CheckEnteredFile(FIn, FOut);
  ReadGraph(FIn);
  GetOstovnyTree(FirstPtr);
END.
